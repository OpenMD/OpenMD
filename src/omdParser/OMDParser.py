# Generated from OMD.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,68,653,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        1,0,5,0,82,8,0,10,0,12,0,85,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,3,1,99,8,1,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,
        3,3,3,111,8,3,1,4,1,4,1,4,5,4,116,8,4,10,4,12,4,119,9,4,1,4,1,4,
        1,5,1,5,1,5,5,5,126,8,5,10,5,12,5,129,9,5,1,5,1,5,1,6,1,6,1,6,5,
        6,136,8,6,10,6,12,6,139,9,6,1,6,1,6,1,7,1,7,1,7,5,7,146,8,7,10,7,
        12,7,149,9,7,1,7,1,7,1,8,1,8,1,8,5,8,156,8,8,10,8,12,8,159,9,8,1,
        8,1,8,1,9,1,9,1,9,5,9,166,8,9,10,9,12,9,169,9,9,1,9,1,9,1,10,1,10,
        1,10,5,10,176,8,10,10,10,12,10,179,9,10,1,10,1,10,1,11,1,11,1,11,
        5,11,186,8,11,10,11,12,11,189,9,11,1,11,1,11,1,12,1,12,1,12,1,12,
        1,12,1,12,1,12,1,12,1,12,1,12,3,12,203,8,12,1,13,1,13,1,13,1,13,
        1,13,1,13,5,13,211,8,13,10,13,12,13,214,9,13,1,13,1,13,1,14,1,14,
        1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,
        1,14,1,14,1,14,1,14,3,14,237,8,14,1,15,1,15,1,15,1,15,1,15,3,15,
        244,8,15,1,15,1,15,5,15,248,8,15,10,15,12,15,251,9,15,1,15,1,15,
        1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
        1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
        1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
        1,16,1,16,1,16,1,16,3,16,298,8,16,1,17,1,17,1,17,1,17,1,17,3,17,
        305,8,17,1,17,1,17,5,17,309,8,17,10,17,12,17,312,9,17,1,17,1,17,
        1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,
        1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,
        1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,
        1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,365,8,18,
        1,19,1,19,1,19,1,19,1,19,3,19,372,8,19,1,19,1,19,5,19,376,8,19,10,
        19,12,19,379,9,19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,
        20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,
        20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,
        20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,
        20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,438,8,20,1,21,1,
        21,1,21,1,21,1,21,3,21,445,8,21,1,21,1,21,5,21,449,8,21,10,21,12,
        21,452,9,21,1,21,1,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,
        22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,
        22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,
        22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,499,8,22,1,23,1,
        23,1,23,1,23,1,23,1,23,5,23,507,8,23,10,23,12,23,510,9,23,1,23,1,
        23,1,24,1,24,1,24,1,24,1,24,1,24,1,24,3,24,521,8,24,1,25,1,25,1,
        25,1,25,1,25,3,25,528,8,25,1,25,1,25,5,25,532,8,25,10,25,12,25,535,
        9,25,1,25,1,25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,546,8,26,
        1,27,1,27,1,27,1,27,1,27,3,27,553,8,27,1,27,1,27,5,27,557,8,27,10,
        27,12,27,560,9,27,1,27,1,27,1,28,1,28,1,28,1,28,1,28,1,28,1,28,3,
        28,571,8,28,1,29,1,29,1,29,5,29,576,8,29,10,29,12,29,579,9,29,1,
        29,1,29,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,593,
        8,30,1,31,1,31,1,31,1,31,1,31,3,31,600,8,31,1,31,1,31,5,31,604,8,
        31,10,31,12,31,607,9,31,1,31,1,31,1,32,1,32,1,32,1,32,1,32,1,32,
        1,32,3,32,618,8,32,1,33,1,33,1,33,1,33,1,33,1,34,1,34,1,34,5,34,
        628,8,34,10,34,12,34,631,9,34,1,35,1,35,1,35,5,35,636,8,35,10,35,
        12,35,639,9,35,1,36,1,36,1,37,1,37,3,37,645,8,37,1,38,1,38,1,39,
        1,39,1,39,1,39,1,39,0,0,40,0,2,4,6,8,10,12,14,16,18,20,22,24,26,
        28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,
        72,74,76,78,0,2,1,0,56,57,1,0,58,59,710,0,83,1,0,0,0,2,98,1,0,0,
        0,4,100,1,0,0,0,6,110,1,0,0,0,8,112,1,0,0,0,10,122,1,0,0,0,12,132,
        1,0,0,0,14,142,1,0,0,0,16,152,1,0,0,0,18,162,1,0,0,0,20,172,1,0,
        0,0,22,182,1,0,0,0,24,202,1,0,0,0,26,204,1,0,0,0,28,236,1,0,0,0,
        30,238,1,0,0,0,32,297,1,0,0,0,34,299,1,0,0,0,36,364,1,0,0,0,38,366,
        1,0,0,0,40,437,1,0,0,0,42,439,1,0,0,0,44,498,1,0,0,0,46,500,1,0,
        0,0,48,520,1,0,0,0,50,522,1,0,0,0,52,545,1,0,0,0,54,547,1,0,0,0,
        56,570,1,0,0,0,58,572,1,0,0,0,60,592,1,0,0,0,62,594,1,0,0,0,64,617,
        1,0,0,0,66,619,1,0,0,0,68,624,1,0,0,0,70,632,1,0,0,0,72,640,1,0,
        0,0,74,644,1,0,0,0,76,646,1,0,0,0,78,648,1,0,0,0,80,82,3,2,1,0,81,
        80,1,0,0,0,82,85,1,0,0,0,83,81,1,0,0,0,83,84,1,0,0,0,84,86,1,0,0,
        0,85,83,1,0,0,0,86,87,5,0,0,1,87,1,1,0,0,0,88,99,3,4,2,0,89,99,3,
        8,4,0,90,99,3,22,11,0,91,99,3,58,29,0,92,99,3,10,5,0,93,99,3,12,
        6,0,94,99,3,14,7,0,95,99,3,16,8,0,96,99,3,18,9,0,97,99,3,20,10,0,
        98,88,1,0,0,0,98,89,1,0,0,0,98,90,1,0,0,0,98,91,1,0,0,0,98,92,1,
        0,0,0,98,93,1,0,0,0,98,94,1,0,0,0,98,95,1,0,0,0,98,96,1,0,0,0,98,
        97,1,0,0,0,99,3,1,0,0,0,100,101,5,62,0,0,101,102,5,44,0,0,102,103,
        3,6,3,0,103,104,5,48,0,0,104,5,1,0,0,0,105,111,3,72,36,0,106,111,
        3,76,38,0,107,111,3,78,39,0,108,111,5,62,0,0,109,111,5,61,0,0,110,
        105,1,0,0,0,110,106,1,0,0,0,110,107,1,0,0,0,110,108,1,0,0,0,110,
        109,1,0,0,0,111,7,1,0,0,0,112,113,5,1,0,0,113,117,5,54,0,0,114,116,
        3,4,2,0,115,114,1,0,0,0,116,119,1,0,0,0,117,115,1,0,0,0,117,118,
        1,0,0,0,118,120,1,0,0,0,119,117,1,0,0,0,120,121,5,55,0,0,121,9,1,
        0,0,0,122,123,5,3,0,0,123,127,5,54,0,0,124,126,3,4,2,0,125,124,1,
        0,0,0,126,129,1,0,0,0,127,125,1,0,0,0,127,128,1,0,0,0,128,130,1,
        0,0,0,129,127,1,0,0,0,130,131,5,55,0,0,131,11,1,0,0,0,132,133,5,
        4,0,0,133,137,5,54,0,0,134,136,3,4,2,0,135,134,1,0,0,0,136,139,1,
        0,0,0,137,135,1,0,0,0,137,138,1,0,0,0,138,140,1,0,0,0,139,137,1,
        0,0,0,140,141,5,55,0,0,141,13,1,0,0,0,142,143,5,21,0,0,143,147,5,
        54,0,0,144,146,3,4,2,0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,
        0,0,0,147,148,1,0,0,0,148,150,1,0,0,0,149,147,1,0,0,0,150,151,5,
        55,0,0,151,15,1,0,0,0,152,153,5,22,0,0,153,157,5,54,0,0,154,156,
        3,4,2,0,155,154,1,0,0,0,156,159,1,0,0,0,157,155,1,0,0,0,157,158,
        1,0,0,0,158,160,1,0,0,0,159,157,1,0,0,0,160,161,5,55,0,0,161,17,
        1,0,0,0,162,163,5,23,0,0,163,167,5,54,0,0,164,166,3,4,2,0,165,164,
        1,0,0,0,166,169,1,0,0,0,167,165,1,0,0,0,167,168,1,0,0,0,168,170,
        1,0,0,0,169,167,1,0,0,0,170,171,5,55,0,0,171,19,1,0,0,0,172,173,
        5,24,0,0,173,177,5,54,0,0,174,176,3,4,2,0,175,174,1,0,0,0,176,179,
        1,0,0,0,177,175,1,0,0,0,177,178,1,0,0,0,178,180,1,0,0,0,179,177,
        1,0,0,0,180,181,5,55,0,0,181,21,1,0,0,0,182,183,5,2,0,0,183,187,
        5,54,0,0,184,186,3,24,12,0,185,184,1,0,0,0,186,189,1,0,0,0,187,185,
        1,0,0,0,187,188,1,0,0,0,188,190,1,0,0,0,189,187,1,0,0,0,190,191,
        5,55,0,0,191,23,1,0,0,0,192,203,3,4,2,0,193,203,3,26,13,0,194,203,
        3,30,15,0,195,203,3,34,17,0,196,203,3,38,19,0,197,203,3,42,21,0,
        198,203,3,46,23,0,199,203,3,50,25,0,200,203,3,62,31,0,201,203,3,
        66,33,0,202,192,1,0,0,0,202,193,1,0,0,0,202,194,1,0,0,0,202,195,
        1,0,0,0,202,196,1,0,0,0,202,197,1,0,0,0,202,198,1,0,0,0,202,199,
        1,0,0,0,202,200,1,0,0,0,202,201,1,0,0,0,203,25,1,0,0,0,204,205,5,
        5,0,0,205,206,5,52,0,0,206,207,3,72,36,0,207,208,5,53,0,0,208,212,
        5,54,0,0,209,211,3,28,14,0,210,209,1,0,0,0,211,214,1,0,0,0,212,210,
        1,0,0,0,212,213,1,0,0,0,213,215,1,0,0,0,214,212,1,0,0,0,215,216,
        5,55,0,0,216,27,1,0,0,0,217,237,3,4,2,0,218,219,5,19,0,0,219,220,
        5,50,0,0,220,221,3,68,34,0,221,222,5,51,0,0,222,223,5,48,0,0,223,
        237,1,0,0,0,224,225,5,20,0,0,225,226,5,50,0,0,226,227,3,68,34,0,
        227,228,5,51,0,0,228,229,5,48,0,0,229,237,1,0,0,0,230,231,5,42,0,
        0,231,232,5,50,0,0,232,233,3,76,38,0,233,234,5,51,0,0,234,235,5,
        48,0,0,235,237,1,0,0,0,236,217,1,0,0,0,236,218,1,0,0,0,236,224,1,
        0,0,0,236,230,1,0,0,0,237,29,1,0,0,0,238,243,5,6,0,0,239,240,5,52,
        0,0,240,241,3,72,36,0,241,242,5,53,0,0,242,244,1,0,0,0,243,239,1,
        0,0,0,243,244,1,0,0,0,244,245,1,0,0,0,245,249,5,54,0,0,246,248,3,
        32,16,0,247,246,1,0,0,0,248,251,1,0,0,0,249,247,1,0,0,0,249,250,
        1,0,0,0,250,252,1,0,0,0,251,249,1,0,0,0,252,253,5,55,0,0,253,31,
        1,0,0,0,254,298,3,4,2,0,255,256,5,16,0,0,256,257,5,50,0,0,257,258,
        3,70,35,0,258,259,5,51,0,0,259,260,5,48,0,0,260,298,1,0,0,0,261,
        262,5,25,0,0,262,263,5,50,0,0,263,264,3,76,38,0,264,265,5,51,0,0,
        265,266,5,48,0,0,266,298,1,0,0,0,267,268,5,26,0,0,268,269,5,50,0,
        0,269,270,3,68,34,0,270,271,5,51,0,0,271,272,5,48,0,0,272,298,1,
        0,0,0,273,274,5,27,0,0,274,275,5,50,0,0,275,276,3,68,34,0,276,277,
        5,51,0,0,277,278,5,48,0,0,278,298,1,0,0,0,279,280,5,28,0,0,280,281,
        5,50,0,0,281,282,3,68,34,0,282,283,5,51,0,0,283,284,5,48,0,0,284,
        298,1,0,0,0,285,286,5,29,0,0,286,287,5,50,0,0,287,288,3,68,34,0,
        288,289,5,51,0,0,289,290,5,48,0,0,290,298,1,0,0,0,291,292,5,30,0,
        0,292,293,5,50,0,0,293,294,3,68,34,0,294,295,5,51,0,0,295,296,5,
        48,0,0,296,298,1,0,0,0,297,254,1,0,0,0,297,255,1,0,0,0,297,261,1,
        0,0,0,297,267,1,0,0,0,297,273,1,0,0,0,297,279,1,0,0,0,297,285,1,
        0,0,0,297,291,1,0,0,0,298,33,1,0,0,0,299,304,5,7,0,0,300,301,5,52,
        0,0,301,302,3,72,36,0,302,303,5,53,0,0,303,305,1,0,0,0,304,300,1,
        0,0,0,304,305,1,0,0,0,305,306,1,0,0,0,306,310,5,54,0,0,307,309,3,
        36,18,0,308,307,1,0,0,0,309,312,1,0,0,0,310,308,1,0,0,0,310,311,
        1,0,0,0,311,313,1,0,0,0,312,310,1,0,0,0,313,314,5,55,0,0,314,35,
        1,0,0,0,315,365,3,4,2,0,316,317,5,16,0,0,317,318,5,50,0,0,318,319,
        3,70,35,0,319,320,5,51,0,0,320,321,5,48,0,0,321,365,1,0,0,0,322,
        323,5,26,0,0,323,324,5,50,0,0,324,325,3,68,34,0,325,326,5,51,0,0,
        326,327,5,48,0,0,327,365,1,0,0,0,328,329,5,31,0,0,329,330,5,50,0,
        0,330,331,3,68,34,0,331,332,5,51,0,0,332,333,5,48,0,0,333,365,1,
        0,0,0,334,335,5,32,0,0,335,336,5,50,0,0,336,337,3,68,34,0,337,338,
        5,51,0,0,338,339,5,48,0,0,339,365,1,0,0,0,340,341,5,27,0,0,341,342,
        5,50,0,0,342,343,3,68,34,0,343,344,5,51,0,0,344,345,5,48,0,0,345,
        365,1,0,0,0,346,347,5,28,0,0,347,348,5,50,0,0,348,349,3,68,34,0,
        349,350,5,51,0,0,350,351,5,48,0,0,351,365,1,0,0,0,352,353,5,29,0,
        0,353,354,5,50,0,0,354,355,3,68,34,0,355,356,5,51,0,0,356,357,5,
        48,0,0,357,365,1,0,0,0,358,359,5,33,0,0,359,360,5,50,0,0,360,361,
        3,68,34,0,361,362,5,51,0,0,362,363,5,48,0,0,363,365,1,0,0,0,364,
        315,1,0,0,0,364,316,1,0,0,0,364,322,1,0,0,0,364,328,1,0,0,0,364,
        334,1,0,0,0,364,340,1,0,0,0,364,346,1,0,0,0,364,352,1,0,0,0,364,
        358,1,0,0,0,365,37,1,0,0,0,366,371,5,8,0,0,367,368,5,52,0,0,368,
        369,3,72,36,0,369,370,5,53,0,0,370,372,1,0,0,0,371,367,1,0,0,0,371,
        372,1,0,0,0,372,373,1,0,0,0,373,377,5,54,0,0,374,376,3,40,20,0,375,
        374,1,0,0,0,376,379,1,0,0,0,377,375,1,0,0,0,377,378,1,0,0,0,378,
        380,1,0,0,0,379,377,1,0,0,0,380,381,5,55,0,0,381,39,1,0,0,0,382,
        438,3,4,2,0,383,384,5,16,0,0,384,385,5,50,0,0,385,386,3,70,35,0,
        386,387,5,51,0,0,387,388,5,48,0,0,388,438,1,0,0,0,389,390,5,34,0,
        0,390,391,5,50,0,0,391,392,3,68,34,0,392,393,5,51,0,0,393,394,5,
        48,0,0,394,438,1,0,0,0,395,396,5,27,0,0,396,397,5,50,0,0,397,398,
        3,68,34,0,398,399,5,51,0,0,399,400,5,48,0,0,400,438,1,0,0,0,401,
        402,5,28,0,0,402,403,5,50,0,0,403,404,3,68,34,0,404,405,5,51,0,0,
        405,406,5,48,0,0,406,438,1,0,0,0,407,408,5,29,0,0,408,409,5,50,0,
        0,409,410,3,68,34,0,410,411,5,51,0,0,411,412,5,48,0,0,412,438,1,
        0,0,0,413,414,5,35,0,0,414,415,5,50,0,0,415,416,3,68,34,0,416,417,
        5,51,0,0,417,418,5,48,0,0,418,438,1,0,0,0,419,420,5,36,0,0,420,421,
        5,50,0,0,421,422,3,68,34,0,422,423,5,51,0,0,423,424,5,48,0,0,424,
        438,1,0,0,0,425,426,5,37,0,0,426,427,5,50,0,0,427,428,3,68,34,0,
        428,429,5,51,0,0,429,430,5,48,0,0,430,438,1,0,0,0,431,432,5,26,0,
        0,432,433,5,50,0,0,433,434,3,68,34,0,434,435,5,51,0,0,435,436,5,
        48,0,0,436,438,1,0,0,0,437,382,1,0,0,0,437,383,1,0,0,0,437,389,1,
        0,0,0,437,395,1,0,0,0,437,401,1,0,0,0,437,407,1,0,0,0,437,413,1,
        0,0,0,437,419,1,0,0,0,437,425,1,0,0,0,437,431,1,0,0,0,438,41,1,0,
        0,0,439,444,5,9,0,0,440,441,5,52,0,0,441,442,3,72,36,0,442,443,5,
        53,0,0,443,445,1,0,0,0,444,440,1,0,0,0,444,445,1,0,0,0,445,446,1,
        0,0,0,446,450,5,54,0,0,447,449,3,44,22,0,448,447,1,0,0,0,449,452,
        1,0,0,0,450,448,1,0,0,0,450,451,1,0,0,0,451,453,1,0,0,0,452,450,
        1,0,0,0,453,454,5,55,0,0,454,43,1,0,0,0,455,499,3,4,2,0,456,457,
        5,17,0,0,457,458,5,50,0,0,458,459,3,72,36,0,459,460,5,51,0,0,460,
        461,5,48,0,0,461,499,1,0,0,0,462,463,5,18,0,0,463,464,5,50,0,0,464,
        465,3,70,35,0,465,466,5,51,0,0,466,467,5,48,0,0,467,499,1,0,0,0,
        468,469,5,38,0,0,469,470,5,50,0,0,470,471,3,68,34,0,471,472,5,51,
        0,0,472,473,5,48,0,0,473,499,1,0,0,0,474,475,5,39,0,0,475,476,5,
        50,0,0,476,477,3,68,34,0,477,478,5,51,0,0,478,479,5,48,0,0,479,499,
        1,0,0,0,480,481,5,26,0,0,481,482,5,50,0,0,482,483,3,68,34,0,483,
        484,5,51,0,0,484,485,5,48,0,0,485,499,1,0,0,0,486,487,5,40,0,0,487,
        488,5,50,0,0,488,489,3,68,34,0,489,490,5,51,0,0,490,491,5,48,0,0,
        491,499,1,0,0,0,492,493,5,41,0,0,493,494,5,50,0,0,494,495,3,68,34,
        0,495,496,5,51,0,0,496,497,5,48,0,0,497,499,1,0,0,0,498,455,1,0,
        0,0,498,456,1,0,0,0,498,462,1,0,0,0,498,468,1,0,0,0,498,474,1,0,
        0,0,498,480,1,0,0,0,498,486,1,0,0,0,498,492,1,0,0,0,499,45,1,0,0,
        0,500,501,5,10,0,0,501,502,5,52,0,0,502,503,3,72,36,0,503,504,5,
        53,0,0,504,508,5,54,0,0,505,507,3,48,24,0,506,505,1,0,0,0,507,510,
        1,0,0,0,508,506,1,0,0,0,508,509,1,0,0,0,509,511,1,0,0,0,510,508,
        1,0,0,0,511,512,5,55,0,0,512,47,1,0,0,0,513,521,3,4,2,0,514,515,
        5,16,0,0,515,516,5,50,0,0,516,517,3,70,35,0,517,518,5,51,0,0,518,
        519,5,48,0,0,519,521,1,0,0,0,520,513,1,0,0,0,520,514,1,0,0,0,521,
        49,1,0,0,0,522,527,5,11,0,0,523,524,5,52,0,0,524,525,3,72,36,0,525,
        526,5,53,0,0,526,528,1,0,0,0,527,523,1,0,0,0,527,528,1,0,0,0,528,
        529,1,0,0,0,529,533,5,54,0,0,530,532,3,52,26,0,531,530,1,0,0,0,532,
        535,1,0,0,0,533,531,1,0,0,0,533,534,1,0,0,0,534,536,1,0,0,0,535,
        533,1,0,0,0,536,537,5,55,0,0,537,51,1,0,0,0,538,546,3,4,2,0,539,
        540,5,16,0,0,540,541,5,50,0,0,541,542,3,70,35,0,542,543,5,51,0,0,
        543,544,5,48,0,0,544,546,1,0,0,0,545,538,1,0,0,0,545,539,1,0,0,0,
        546,53,1,0,0,0,547,552,5,43,0,0,548,549,5,52,0,0,549,550,3,72,36,
        0,550,551,5,53,0,0,551,553,1,0,0,0,552,548,1,0,0,0,552,553,1,0,0,
        0,553,554,1,0,0,0,554,558,5,54,0,0,555,557,3,56,28,0,556,555,1,0,
        0,0,557,560,1,0,0,0,558,556,1,0,0,0,558,559,1,0,0,0,559,561,1,0,
        0,0,560,558,1,0,0,0,561,562,5,55,0,0,562,55,1,0,0,0,563,571,3,4,
        2,0,564,565,5,16,0,0,565,566,5,50,0,0,566,567,3,70,35,0,567,568,
        5,51,0,0,568,569,5,48,0,0,569,571,1,0,0,0,570,563,1,0,0,0,570,564,
        1,0,0,0,571,57,1,0,0,0,572,573,5,14,0,0,573,577,5,54,0,0,574,576,
        3,60,30,0,575,574,1,0,0,0,576,579,1,0,0,0,577,575,1,0,0,0,577,578,
        1,0,0,0,578,580,1,0,0,0,579,577,1,0,0,0,580,581,5,55,0,0,581,59,
        1,0,0,0,582,593,3,4,2,0,583,593,3,26,13,0,584,593,3,30,15,0,585,
        593,3,34,17,0,586,593,3,38,19,0,587,593,3,42,21,0,588,593,3,46,23,
        0,589,593,3,50,25,0,590,593,3,62,31,0,591,593,3,54,27,0,592,582,
        1,0,0,0,592,583,1,0,0,0,592,584,1,0,0,0,592,585,1,0,0,0,592,586,
        1,0,0,0,592,587,1,0,0,0,592,588,1,0,0,0,592,589,1,0,0,0,592,590,
        1,0,0,0,592,591,1,0,0,0,593,61,1,0,0,0,594,599,5,12,0,0,595,596,
        5,52,0,0,596,597,3,72,36,0,597,598,5,53,0,0,598,600,1,0,0,0,599,
        595,1,0,0,0,599,600,1,0,0,0,600,601,1,0,0,0,601,605,5,54,0,0,602,
        604,3,64,32,0,603,602,1,0,0,0,604,607,1,0,0,0,605,603,1,0,0,0,605,
        606,1,0,0,0,606,608,1,0,0,0,607,605,1,0,0,0,608,609,5,55,0,0,609,
        63,1,0,0,0,610,618,3,4,2,0,611,612,5,16,0,0,612,613,5,50,0,0,613,
        614,3,70,35,0,614,615,5,51,0,0,615,616,5,48,0,0,616,618,1,0,0,0,
        617,610,1,0,0,0,617,611,1,0,0,0,618,65,1,0,0,0,619,620,5,15,0,0,
        620,621,5,44,0,0,621,622,3,6,3,0,622,623,5,48,0,0,623,67,1,0,0,0,
        624,629,3,74,37,0,625,626,5,46,0,0,626,628,3,74,37,0,627,625,1,0,
        0,0,628,631,1,0,0,0,629,627,1,0,0,0,629,630,1,0,0,0,630,69,1,0,0,
        0,631,629,1,0,0,0,632,637,3,72,36,0,633,634,5,46,0,0,634,636,3,72,
        36,0,635,633,1,0,0,0,636,639,1,0,0,0,637,635,1,0,0,0,637,638,1,0,
        0,0,638,71,1,0,0,0,639,637,1,0,0,0,640,641,7,0,0,0,641,73,1,0,0,
        0,642,645,3,72,36,0,643,645,3,76,38,0,644,642,1,0,0,0,644,643,1,
        0,0,0,645,75,1,0,0,0,646,647,7,1,0,0,647,77,1,0,0,0,648,649,5,50,
        0,0,649,650,3,68,34,0,650,651,5,51,0,0,651,79,1,0,0,0,42,83,98,110,
        117,127,137,147,157,167,177,187,202,212,236,243,249,297,304,310,
        364,371,377,437,444,450,498,508,520,527,533,545,552,558,570,577,
        592,599,605,617,629,637,644
    ]

class OMDParser ( Parser ):

    grammarFileName = "OMD.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'component'", "'molecule'", "'zconstraint'", 
                     "'restraint'", "'atom'", "'bond'", "'bend'", "'torsion'", 
                     "'inversion'", "'rigidBody'", "'cutoffGroup'", "'constraint'", 
                     "'distance'", "'fragment'", "'sequence'", "'members'", 
                     "'center'", "'satellites'", "'position'", "'orientation'", 
                     "'flucQ'", "'RNEMD'", "'light'", "'minimizer'", "'Fixed'", 
                     "'Harmonic'", "'Cubic'", "'Quartic'", "'Polynomial'", 
                     "'Morse'", "'GhostBend'", "'UreyBradley'", "'Cosine'", 
                     "'GhostTorsion'", "'Charmm'", "'Opls'", "'Trappe'", 
                     "'AmberImproper'", "'ImproperCosine'", "'CentralAtomHeight'", 
                     "'Dreiding'", "'charge'", "'nodes'", "'='", "':'", 
                     "','", "'?'", "';'", "'.'", "'('", "')'", "'['", "']'", 
                     "'{'", "'}'" ]

    symbolicNames = [ "<INVALID>", "COMPONENT", "MOLECULE", "ZCONSTRAINT", 
                      "RESTRAINT", "ATOM", "BOND", "BEND", "TORSION", "INVERSION", 
                      "RIGIDBODY", "CUTOFFGROUP", "CONSTRAINT", "DISTANCE", 
                      "FRAGMENT", "SEQUENCE", "MEMBERS", "CENTER", "SATELLITES", 
                      "POSITION", "ORIENTATION", "FLUCQ", "RNEMD", "LIGHT", 
                      "MINIMIZER", "FIXED", "HARMONIC", "CUBIC", "QUARTIC", 
                      "POLYNOMIAL", "MORSE", "GHOSTBEND", "UREYBRADLEY", 
                      "COSINE", "GHOSTTORSION", "CHARMM", "OPLS", "TRAPPE", 
                      "AMBERIMPROPER", "IMPROPERCOSINE", "CENTRALATOMHEIGHT", 
                      "DREIDING", "CHARGE", "NODES", "ASSIGNEQUAL", "COLON", 
                      "COMMA", "QUESTIONMARK", "SEMICOLON", "DOT", "LPAREN", 
                      "RPAREN", "LBRACKET", "RBRACKET", "LCURLY", "RCURLY", 
                      "NUM_LONG", "NUM_INT", "NUM_FLOAT", "NUM_DOUBLE", 
                      "CharLiteral", "StringLiteral", "ID", "Whitespace", 
                      "Newline", "LineContinuation", "Comment", "CPPComment", 
                      "PREPROC_DIRECTIVE" ]

    RULE_omdfile = 0
    RULE_statement = 1
    RULE_assignment = 2
    RULE_constant = 3
    RULE_componentblock = 4
    RULE_zconstraintblock = 5
    RULE_restraintblock = 6
    RULE_flucqblock = 7
    RULE_rnemdblock = 8
    RULE_lightblock = 9
    RULE_minimizerblock = 10
    RULE_moleculeblock = 11
    RULE_moleculestatement = 12
    RULE_atomblock = 13
    RULE_atomstatement = 14
    RULE_bondblock = 15
    RULE_bondstatement = 16
    RULE_bendblock = 17
    RULE_bendstatement = 18
    RULE_torsionblock = 19
    RULE_torsionstatement = 20
    RULE_inversionblock = 21
    RULE_inversionstatement = 22
    RULE_rigidbodyblock = 23
    RULE_rigidbodystatement = 24
    RULE_cutoffgroupblock = 25
    RULE_cutoffgroupstatement = 26
    RULE_nodesblock = 27
    RULE_nodesstatement = 28
    RULE_fragmentblock = 29
    RULE_fragmentstatement = 30
    RULE_constraintblock = 31
    RULE_constraintstatement = 32
    RULE_sequencestring = 33
    RULE_doubleNumberTuple = 34
    RULE_inttuple = 35
    RULE_intConst = 36
    RULE_doubleNumber = 37
    RULE_floatConst = 38
    RULE_vectorConst = 39

    ruleNames =  [ "omdfile", "statement", "assignment", "constant", "componentblock", 
                   "zconstraintblock", "restraintblock", "flucqblock", "rnemdblock", 
                   "lightblock", "minimizerblock", "moleculeblock", "moleculestatement", 
                   "atomblock", "atomstatement", "bondblock", "bondstatement", 
                   "bendblock", "bendstatement", "torsionblock", "torsionstatement", 
                   "inversionblock", "inversionstatement", "rigidbodyblock", 
                   "rigidbodystatement", "cutoffgroupblock", "cutoffgroupstatement", 
                   "nodesblock", "nodesstatement", "fragmentblock", "fragmentstatement", 
                   "constraintblock", "constraintstatement", "sequencestring", 
                   "doubleNumberTuple", "inttuple", "intConst", "doubleNumber", 
                   "floatConst", "vectorConst" ]

    EOF = Token.EOF
    COMPONENT=1
    MOLECULE=2
    ZCONSTRAINT=3
    RESTRAINT=4
    ATOM=5
    BOND=6
    BEND=7
    TORSION=8
    INVERSION=9
    RIGIDBODY=10
    CUTOFFGROUP=11
    CONSTRAINT=12
    DISTANCE=13
    FRAGMENT=14
    SEQUENCE=15
    MEMBERS=16
    CENTER=17
    SATELLITES=18
    POSITION=19
    ORIENTATION=20
    FLUCQ=21
    RNEMD=22
    LIGHT=23
    MINIMIZER=24
    FIXED=25
    HARMONIC=26
    CUBIC=27
    QUARTIC=28
    POLYNOMIAL=29
    MORSE=30
    GHOSTBEND=31
    UREYBRADLEY=32
    COSINE=33
    GHOSTTORSION=34
    CHARMM=35
    OPLS=36
    TRAPPE=37
    AMBERIMPROPER=38
    IMPROPERCOSINE=39
    CENTRALATOMHEIGHT=40
    DREIDING=41
    CHARGE=42
    NODES=43
    ASSIGNEQUAL=44
    COLON=45
    COMMA=46
    QUESTIONMARK=47
    SEMICOLON=48
    DOT=49
    LPAREN=50
    RPAREN=51
    LBRACKET=52
    RBRACKET=53
    LCURLY=54
    RCURLY=55
    NUM_LONG=56
    NUM_INT=57
    NUM_FLOAT=58
    NUM_DOUBLE=59
    CharLiteral=60
    StringLiteral=61
    ID=62
    Whitespace=63
    Newline=64
    LineContinuation=65
    Comment=66
    CPPComment=67
    PREPROC_DIRECTIVE=68

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class OmdfileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(OMDParser.EOF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.StatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.StatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_omdfile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOmdfile" ):
                listener.enterOmdfile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOmdfile" ):
                listener.exitOmdfile(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOmdfile" ):
                return visitor.visitOmdfile(self)
            else:
                return visitor.visitChildren(self)




    def omdfile(self):

        localctx = OMDParser.OmdfileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_omdfile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4611686018458861598) != 0):
                self.state = 80
                self.statement()
                self.state = 85
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 86
            self.match(OMDParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def componentblock(self):
            return self.getTypedRuleContext(OMDParser.ComponentblockContext,0)


        def moleculeblock(self):
            return self.getTypedRuleContext(OMDParser.MoleculeblockContext,0)


        def fragmentblock(self):
            return self.getTypedRuleContext(OMDParser.FragmentblockContext,0)


        def zconstraintblock(self):
            return self.getTypedRuleContext(OMDParser.ZconstraintblockContext,0)


        def restraintblock(self):
            return self.getTypedRuleContext(OMDParser.RestraintblockContext,0)


        def flucqblock(self):
            return self.getTypedRuleContext(OMDParser.FlucqblockContext,0)


        def rnemdblock(self):
            return self.getTypedRuleContext(OMDParser.RnemdblockContext,0)


        def lightblock(self):
            return self.getTypedRuleContext(OMDParser.LightblockContext,0)


        def minimizerblock(self):
            return self.getTypedRuleContext(OMDParser.MinimizerblockContext,0)


        def getRuleIndex(self):
            return OMDParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = OMDParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 98
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 88
                self.assignment()
                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 89
                self.componentblock()
                pass
            elif token in [2]:
                self.enterOuterAlt(localctx, 3)
                self.state = 90
                self.moleculeblock()
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 4)
                self.state = 91
                self.fragmentblock()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 5)
                self.state = 92
                self.zconstraintblock()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 6)
                self.state = 93
                self.restraintblock()
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 7)
                self.state = 94
                self.flucqblock()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 8)
                self.state = 95
                self.rnemdblock()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 9)
                self.state = 96
                self.lightblock()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 10)
                self.state = 97
                self.minimizerblock()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(OMDParser.ID, 0)

        def ASSIGNEQUAL(self):
            return self.getToken(OMDParser.ASSIGNEQUAL, 0)

        def constant(self):
            return self.getTypedRuleContext(OMDParser.ConstantContext,0)


        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = OMDParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(OMDParser.ID)
            self.state = 101
            self.match(OMDParser.ASSIGNEQUAL)
            self.state = 102
            self.constant()
            self.state = 103
            self.match(OMDParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def floatConst(self):
            return self.getTypedRuleContext(OMDParser.FloatConstContext,0)


        def vectorConst(self):
            return self.getTypedRuleContext(OMDParser.VectorConstContext,0)


        def ID(self):
            return self.getToken(OMDParser.ID, 0)

        def StringLiteral(self):
            return self.getToken(OMDParser.StringLiteral, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant" ):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)




    def constant(self):

        localctx = OMDParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_constant)
        try:
            self.state = 110
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [56, 57]:
                self.enterOuterAlt(localctx, 1)
                self.state = 105
                self.intConst()
                pass
            elif token in [58, 59]:
                self.enterOuterAlt(localctx, 2)
                self.state = 106
                self.floatConst()
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 3)
                self.state = 107
                self.vectorConst()
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 4)
                self.state = 108
                self.match(OMDParser.ID)
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 5)
                self.state = 109
                self.match(OMDParser.StringLiteral)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComponentblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPONENT(self):
            return self.getToken(OMDParser.COMPONENT, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(OMDParser.AssignmentContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_componentblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponentblock" ):
                listener.enterComponentblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponentblock" ):
                listener.exitComponentblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponentblock" ):
                return visitor.visitComponentblock(self)
            else:
                return visitor.visitChildren(self)




    def componentblock(self):

        localctx = OMDParser.ComponentblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_componentblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.match(OMDParser.COMPONENT)
            self.state = 113
            self.match(OMDParser.LCURLY)
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==62:
                self.state = 114
                self.assignment()
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 120
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ZconstraintblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZCONSTRAINT(self):
            return self.getToken(OMDParser.ZCONSTRAINT, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(OMDParser.AssignmentContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_zconstraintblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZconstraintblock" ):
                listener.enterZconstraintblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZconstraintblock" ):
                listener.exitZconstraintblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZconstraintblock" ):
                return visitor.visitZconstraintblock(self)
            else:
                return visitor.visitChildren(self)




    def zconstraintblock(self):

        localctx = OMDParser.ZconstraintblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_zconstraintblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(OMDParser.ZCONSTRAINT)
            self.state = 123
            self.match(OMDParser.LCURLY)
            self.state = 127
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==62:
                self.state = 124
                self.assignment()
                self.state = 129
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 130
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RestraintblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESTRAINT(self):
            return self.getToken(OMDParser.RESTRAINT, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(OMDParser.AssignmentContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_restraintblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRestraintblock" ):
                listener.enterRestraintblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRestraintblock" ):
                listener.exitRestraintblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRestraintblock" ):
                return visitor.visitRestraintblock(self)
            else:
                return visitor.visitChildren(self)




    def restraintblock(self):

        localctx = OMDParser.RestraintblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_restraintblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(OMDParser.RESTRAINT)
            self.state = 133
            self.match(OMDParser.LCURLY)
            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==62:
                self.state = 134
                self.assignment()
                self.state = 139
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 140
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FlucqblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLUCQ(self):
            return self.getToken(OMDParser.FLUCQ, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(OMDParser.AssignmentContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_flucqblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlucqblock" ):
                listener.enterFlucqblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlucqblock" ):
                listener.exitFlucqblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlucqblock" ):
                return visitor.visitFlucqblock(self)
            else:
                return visitor.visitChildren(self)




    def flucqblock(self):

        localctx = OMDParser.FlucqblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_flucqblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(OMDParser.FLUCQ)
            self.state = 143
            self.match(OMDParser.LCURLY)
            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==62:
                self.state = 144
                self.assignment()
                self.state = 149
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 150
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RnemdblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RNEMD(self):
            return self.getToken(OMDParser.RNEMD, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(OMDParser.AssignmentContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_rnemdblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRnemdblock" ):
                listener.enterRnemdblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRnemdblock" ):
                listener.exitRnemdblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRnemdblock" ):
                return visitor.visitRnemdblock(self)
            else:
                return visitor.visitChildren(self)




    def rnemdblock(self):

        localctx = OMDParser.RnemdblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_rnemdblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.match(OMDParser.RNEMD)
            self.state = 153
            self.match(OMDParser.LCURLY)
            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==62:
                self.state = 154
                self.assignment()
                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 160
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LightblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIGHT(self):
            return self.getToken(OMDParser.LIGHT, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(OMDParser.AssignmentContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_lightblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLightblock" ):
                listener.enterLightblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLightblock" ):
                listener.exitLightblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLightblock" ):
                return visitor.visitLightblock(self)
            else:
                return visitor.visitChildren(self)




    def lightblock(self):

        localctx = OMDParser.LightblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_lightblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.match(OMDParser.LIGHT)
            self.state = 163
            self.match(OMDParser.LCURLY)
            self.state = 167
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==62:
                self.state = 164
                self.assignment()
                self.state = 169
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 170
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinimizerblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINIMIZER(self):
            return self.getToken(OMDParser.MINIMIZER, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(OMDParser.AssignmentContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_minimizerblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinimizerblock" ):
                listener.enterMinimizerblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinimizerblock" ):
                listener.exitMinimizerblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinimizerblock" ):
                return visitor.visitMinimizerblock(self)
            else:
                return visitor.visitChildren(self)




    def minimizerblock(self):

        localctx = OMDParser.MinimizerblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_minimizerblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(OMDParser.MINIMIZER)
            self.state = 173
            self.match(OMDParser.LCURLY)
            self.state = 177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==62:
                self.state = 174
                self.assignment()
                self.state = 179
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 180
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoleculeblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MOLECULE(self):
            return self.getToken(OMDParser.MOLECULE, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def moleculestatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.MoleculestatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.MoleculestatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_moleculeblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMoleculeblock" ):
                listener.enterMoleculeblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMoleculeblock" ):
                listener.exitMoleculeblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMoleculeblock" ):
                return visitor.visitMoleculeblock(self)
            else:
                return visitor.visitChildren(self)




    def moleculeblock(self):

        localctx = OMDParser.MoleculeblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_moleculeblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(OMDParser.MOLECULE)
            self.state = 183
            self.match(OMDParser.LCURLY)
            self.state = 187
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4611686018427428832) != 0):
                self.state = 184
                self.moleculestatement()
                self.state = 189
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 190
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoleculestatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def atomblock(self):
            return self.getTypedRuleContext(OMDParser.AtomblockContext,0)


        def bondblock(self):
            return self.getTypedRuleContext(OMDParser.BondblockContext,0)


        def bendblock(self):
            return self.getTypedRuleContext(OMDParser.BendblockContext,0)


        def torsionblock(self):
            return self.getTypedRuleContext(OMDParser.TorsionblockContext,0)


        def inversionblock(self):
            return self.getTypedRuleContext(OMDParser.InversionblockContext,0)


        def rigidbodyblock(self):
            return self.getTypedRuleContext(OMDParser.RigidbodyblockContext,0)


        def cutoffgroupblock(self):
            return self.getTypedRuleContext(OMDParser.CutoffgroupblockContext,0)


        def constraintblock(self):
            return self.getTypedRuleContext(OMDParser.ConstraintblockContext,0)


        def sequencestring(self):
            return self.getTypedRuleContext(OMDParser.SequencestringContext,0)


        def getRuleIndex(self):
            return OMDParser.RULE_moleculestatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMoleculestatement" ):
                listener.enterMoleculestatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMoleculestatement" ):
                listener.exitMoleculestatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMoleculestatement" ):
                return visitor.visitMoleculestatement(self)
            else:
                return visitor.visitChildren(self)




    def moleculestatement(self):

        localctx = OMDParser.MoleculestatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_moleculestatement)
        try:
            self.state = 202
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 192
                self.assignment()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 193
                self.atomblock()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 194
                self.bondblock()
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 4)
                self.state = 195
                self.bendblock()
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 5)
                self.state = 196
                self.torsionblock()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 6)
                self.state = 197
                self.inversionblock()
                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 7)
                self.state = 198
                self.rigidbodyblock()
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 8)
                self.state = 199
                self.cutoffgroupblock()
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 9)
                self.state = 200
                self.constraintblock()
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 10)
                self.state = 201
                self.sequencestring()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM(self):
            return self.getToken(OMDParser.ATOM, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def atomstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.AtomstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.AtomstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_atomblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomblock" ):
                listener.enterAtomblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomblock" ):
                listener.exitAtomblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomblock" ):
                return visitor.visitAtomblock(self)
            else:
                return visitor.visitChildren(self)




    def atomblock(self):

        localctx = OMDParser.AtomblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_atomblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            self.match(OMDParser.ATOM)
            self.state = 205
            self.match(OMDParser.LBRACKET)
            self.state = 206
            self.intConst()
            self.state = 207
            self.match(OMDParser.RBRACKET)
            self.state = 208
            self.match(OMDParser.LCURLY)
            self.state = 212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4611690416475471872) != 0):
                self.state = 209
                self.atomstatement()
                self.state = 214
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 215
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def POSITION(self):
            return self.getToken(OMDParser.POSITION, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def doubleNumberTuple(self):
            return self.getTypedRuleContext(OMDParser.DoubleNumberTupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def ORIENTATION(self):
            return self.getToken(OMDParser.ORIENTATION, 0)

        def CHARGE(self):
            return self.getToken(OMDParser.CHARGE, 0)

        def floatConst(self):
            return self.getTypedRuleContext(OMDParser.FloatConstContext,0)


        def getRuleIndex(self):
            return OMDParser.RULE_atomstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomstatement" ):
                listener.enterAtomstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomstatement" ):
                listener.exitAtomstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomstatement" ):
                return visitor.visitAtomstatement(self)
            else:
                return visitor.visitChildren(self)




    def atomstatement(self):

        localctx = OMDParser.AtomstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_atomstatement)
        try:
            self.state = 236
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 217
                self.assignment()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 218
                self.match(OMDParser.POSITION)
                self.state = 219
                self.match(OMDParser.LPAREN)
                self.state = 220
                self.doubleNumberTuple()
                self.state = 221
                self.match(OMDParser.RPAREN)
                self.state = 222
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 3)
                self.state = 224
                self.match(OMDParser.ORIENTATION)
                self.state = 225
                self.match(OMDParser.LPAREN)
                self.state = 226
                self.doubleNumberTuple()
                self.state = 227
                self.match(OMDParser.RPAREN)
                self.state = 228
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [42]:
                self.enterOuterAlt(localctx, 4)
                self.state = 230
                self.match(OMDParser.CHARGE)
                self.state = 231
                self.match(OMDParser.LPAREN)
                self.state = 232
                self.floatConst()
                self.state = 233
                self.match(OMDParser.RPAREN)
                self.state = 234
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BondblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOND(self):
            return self.getToken(OMDParser.BOND, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def bondstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.BondstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.BondstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_bondblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBondblock" ):
                listener.enterBondblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBondblock" ):
                listener.exitBondblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBondblock" ):
                return visitor.visitBondblock(self)
            else:
                return visitor.visitChildren(self)




    def bondblock(self):

        localctx = OMDParser.BondblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_bondblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.match(OMDParser.BOND)
            self.state = 243
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 239
                self.match(OMDParser.LBRACKET)
                self.state = 240
                self.intConst()
                self.state = 241
                self.match(OMDParser.RBRACKET)


            self.state = 245
            self.match(OMDParser.LCURLY)
            self.state = 249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4611686020541382656) != 0):
                self.state = 246
                self.bondstatement()
                self.state = 251
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 252
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BondstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def MEMBERS(self):
            return self.getToken(OMDParser.MEMBERS, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def inttuple(self):
            return self.getTypedRuleContext(OMDParser.InttupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def FIXED(self):
            return self.getToken(OMDParser.FIXED, 0)

        def floatConst(self):
            return self.getTypedRuleContext(OMDParser.FloatConstContext,0)


        def HARMONIC(self):
            return self.getToken(OMDParser.HARMONIC, 0)

        def doubleNumberTuple(self):
            return self.getTypedRuleContext(OMDParser.DoubleNumberTupleContext,0)


        def CUBIC(self):
            return self.getToken(OMDParser.CUBIC, 0)

        def QUARTIC(self):
            return self.getToken(OMDParser.QUARTIC, 0)

        def POLYNOMIAL(self):
            return self.getToken(OMDParser.POLYNOMIAL, 0)

        def MORSE(self):
            return self.getToken(OMDParser.MORSE, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_bondstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBondstatement" ):
                listener.enterBondstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBondstatement" ):
                listener.exitBondstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBondstatement" ):
                return visitor.visitBondstatement(self)
            else:
                return visitor.visitChildren(self)




    def bondstatement(self):

        localctx = OMDParser.BondstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_bondstatement)
        try:
            self.state = 297
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 254
                self.assignment()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 255
                self.match(OMDParser.MEMBERS)
                self.state = 256
                self.match(OMDParser.LPAREN)
                self.state = 257
                self.inttuple()
                self.state = 258
                self.match(OMDParser.RPAREN)
                self.state = 259
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 3)
                self.state = 261
                self.match(OMDParser.FIXED)
                self.state = 262
                self.match(OMDParser.LPAREN)
                self.state = 263
                self.floatConst()
                self.state = 264
                self.match(OMDParser.RPAREN)
                self.state = 265
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 4)
                self.state = 267
                self.match(OMDParser.HARMONIC)
                self.state = 268
                self.match(OMDParser.LPAREN)
                self.state = 269
                self.doubleNumberTuple()
                self.state = 270
                self.match(OMDParser.RPAREN)
                self.state = 271
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 5)
                self.state = 273
                self.match(OMDParser.CUBIC)
                self.state = 274
                self.match(OMDParser.LPAREN)
                self.state = 275
                self.doubleNumberTuple()
                self.state = 276
                self.match(OMDParser.RPAREN)
                self.state = 277
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 6)
                self.state = 279
                self.match(OMDParser.QUARTIC)
                self.state = 280
                self.match(OMDParser.LPAREN)
                self.state = 281
                self.doubleNumberTuple()
                self.state = 282
                self.match(OMDParser.RPAREN)
                self.state = 283
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 7)
                self.state = 285
                self.match(OMDParser.POLYNOMIAL)
                self.state = 286
                self.match(OMDParser.LPAREN)
                self.state = 287
                self.doubleNumberTuple()
                self.state = 288
                self.match(OMDParser.RPAREN)
                self.state = 289
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [30]:
                self.enterOuterAlt(localctx, 8)
                self.state = 291
                self.match(OMDParser.MORSE)
                self.state = 292
                self.match(OMDParser.LPAREN)
                self.state = 293
                self.doubleNumberTuple()
                self.state = 294
                self.match(OMDParser.RPAREN)
                self.state = 295
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BendblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEND(self):
            return self.getToken(OMDParser.BEND, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def bendstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.BendstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.BendstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_bendblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBendblock" ):
                listener.enterBendblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBendblock" ):
                listener.exitBendblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBendblock" ):
                return visitor.visitBendblock(self)
            else:
                return visitor.visitChildren(self)




    def bendblock(self):

        localctx = OMDParser.BendblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_bendblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.match(OMDParser.BEND)
            self.state = 304
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 300
                self.match(OMDParser.LBRACKET)
                self.state = 301
                self.intConst()
                self.state = 302
                self.match(OMDParser.RBRACKET)


            self.state = 306
            self.match(OMDParser.LCURLY)
            self.state = 310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4611686034466471936) != 0):
                self.state = 307
                self.bendstatement()
                self.state = 312
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 313
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BendstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def MEMBERS(self):
            return self.getToken(OMDParser.MEMBERS, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def inttuple(self):
            return self.getTypedRuleContext(OMDParser.InttupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def HARMONIC(self):
            return self.getToken(OMDParser.HARMONIC, 0)

        def doubleNumberTuple(self):
            return self.getTypedRuleContext(OMDParser.DoubleNumberTupleContext,0)


        def GHOSTBEND(self):
            return self.getToken(OMDParser.GHOSTBEND, 0)

        def UREYBRADLEY(self):
            return self.getToken(OMDParser.UREYBRADLEY, 0)

        def CUBIC(self):
            return self.getToken(OMDParser.CUBIC, 0)

        def QUARTIC(self):
            return self.getToken(OMDParser.QUARTIC, 0)

        def POLYNOMIAL(self):
            return self.getToken(OMDParser.POLYNOMIAL, 0)

        def COSINE(self):
            return self.getToken(OMDParser.COSINE, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_bendstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBendstatement" ):
                listener.enterBendstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBendstatement" ):
                listener.exitBendstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBendstatement" ):
                return visitor.visitBendstatement(self)
            else:
                return visitor.visitChildren(self)




    def bendstatement(self):

        localctx = OMDParser.BendstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_bendstatement)
        try:
            self.state = 364
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 315
                self.assignment()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 316
                self.match(OMDParser.MEMBERS)
                self.state = 317
                self.match(OMDParser.LPAREN)
                self.state = 318
                self.inttuple()
                self.state = 319
                self.match(OMDParser.RPAREN)
                self.state = 320
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 3)
                self.state = 322
                self.match(OMDParser.HARMONIC)
                self.state = 323
                self.match(OMDParser.LPAREN)
                self.state = 324
                self.doubleNumberTuple()
                self.state = 325
                self.match(OMDParser.RPAREN)
                self.state = 326
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 4)
                self.state = 328
                self.match(OMDParser.GHOSTBEND)
                self.state = 329
                self.match(OMDParser.LPAREN)
                self.state = 330
                self.doubleNumberTuple()
                self.state = 331
                self.match(OMDParser.RPAREN)
                self.state = 332
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [32]:
                self.enterOuterAlt(localctx, 5)
                self.state = 334
                self.match(OMDParser.UREYBRADLEY)
                self.state = 335
                self.match(OMDParser.LPAREN)
                self.state = 336
                self.doubleNumberTuple()
                self.state = 337
                self.match(OMDParser.RPAREN)
                self.state = 338
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 6)
                self.state = 340
                self.match(OMDParser.CUBIC)
                self.state = 341
                self.match(OMDParser.LPAREN)
                self.state = 342
                self.doubleNumberTuple()
                self.state = 343
                self.match(OMDParser.RPAREN)
                self.state = 344
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 7)
                self.state = 346
                self.match(OMDParser.QUARTIC)
                self.state = 347
                self.match(OMDParser.LPAREN)
                self.state = 348
                self.doubleNumberTuple()
                self.state = 349
                self.match(OMDParser.RPAREN)
                self.state = 350
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 8)
                self.state = 352
                self.match(OMDParser.POLYNOMIAL)
                self.state = 353
                self.match(OMDParser.LPAREN)
                self.state = 354
                self.doubleNumberTuple()
                self.state = 355
                self.match(OMDParser.RPAREN)
                self.state = 356
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 9)
                self.state = 358
                self.match(OMDParser.COSINE)
                self.state = 359
                self.match(OMDParser.LPAREN)
                self.state = 360
                self.doubleNumberTuple()
                self.state = 361
                self.match(OMDParser.RPAREN)
                self.state = 362
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TorsionblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TORSION(self):
            return self.getToken(OMDParser.TORSION, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def torsionstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.TorsionstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.TorsionstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_torsionblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTorsionblock" ):
                listener.enterTorsionblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTorsionblock" ):
                listener.exitTorsionblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTorsionblock" ):
                return visitor.visitTorsionblock(self)
            else:
                return visitor.visitChildren(self)




    def torsionblock(self):

        localctx = OMDParser.TorsionblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_torsionblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 366
            self.match(OMDParser.TORSION)
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 367
                self.match(OMDParser.LBRACKET)
                self.state = 368
                self.intConst()
                self.state = 369
                self.match(OMDParser.RBRACKET)


            self.state = 373
            self.match(OMDParser.LCURLY)
            self.state = 377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4611686277132124160) != 0):
                self.state = 374
                self.torsionstatement()
                self.state = 379
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 380
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TorsionstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def MEMBERS(self):
            return self.getToken(OMDParser.MEMBERS, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def inttuple(self):
            return self.getTypedRuleContext(OMDParser.InttupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def GHOSTTORSION(self):
            return self.getToken(OMDParser.GHOSTTORSION, 0)

        def doubleNumberTuple(self):
            return self.getTypedRuleContext(OMDParser.DoubleNumberTupleContext,0)


        def CUBIC(self):
            return self.getToken(OMDParser.CUBIC, 0)

        def QUARTIC(self):
            return self.getToken(OMDParser.QUARTIC, 0)

        def POLYNOMIAL(self):
            return self.getToken(OMDParser.POLYNOMIAL, 0)

        def CHARMM(self):
            return self.getToken(OMDParser.CHARMM, 0)

        def OPLS(self):
            return self.getToken(OMDParser.OPLS, 0)

        def TRAPPE(self):
            return self.getToken(OMDParser.TRAPPE, 0)

        def HARMONIC(self):
            return self.getToken(OMDParser.HARMONIC, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_torsionstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTorsionstatement" ):
                listener.enterTorsionstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTorsionstatement" ):
                listener.exitTorsionstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTorsionstatement" ):
                return visitor.visitTorsionstatement(self)
            else:
                return visitor.visitChildren(self)




    def torsionstatement(self):

        localctx = OMDParser.TorsionstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_torsionstatement)
        try:
            self.state = 437
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 382
                self.assignment()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 383
                self.match(OMDParser.MEMBERS)
                self.state = 384
                self.match(OMDParser.LPAREN)
                self.state = 385
                self.inttuple()
                self.state = 386
                self.match(OMDParser.RPAREN)
                self.state = 387
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [34]:
                self.enterOuterAlt(localctx, 3)
                self.state = 389
                self.match(OMDParser.GHOSTTORSION)
                self.state = 390
                self.match(OMDParser.LPAREN)
                self.state = 391
                self.doubleNumberTuple()
                self.state = 392
                self.match(OMDParser.RPAREN)
                self.state = 393
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 4)
                self.state = 395
                self.match(OMDParser.CUBIC)
                self.state = 396
                self.match(OMDParser.LPAREN)
                self.state = 397
                self.doubleNumberTuple()
                self.state = 398
                self.match(OMDParser.RPAREN)
                self.state = 399
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 5)
                self.state = 401
                self.match(OMDParser.QUARTIC)
                self.state = 402
                self.match(OMDParser.LPAREN)
                self.state = 403
                self.doubleNumberTuple()
                self.state = 404
                self.match(OMDParser.RPAREN)
                self.state = 405
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 6)
                self.state = 407
                self.match(OMDParser.POLYNOMIAL)
                self.state = 408
                self.match(OMDParser.LPAREN)
                self.state = 409
                self.doubleNumberTuple()
                self.state = 410
                self.match(OMDParser.RPAREN)
                self.state = 411
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 7)
                self.state = 413
                self.match(OMDParser.CHARMM)
                self.state = 414
                self.match(OMDParser.LPAREN)
                self.state = 415
                self.doubleNumberTuple()
                self.state = 416
                self.match(OMDParser.RPAREN)
                self.state = 417
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [36]:
                self.enterOuterAlt(localctx, 8)
                self.state = 419
                self.match(OMDParser.OPLS)
                self.state = 420
                self.match(OMDParser.LPAREN)
                self.state = 421
                self.doubleNumberTuple()
                self.state = 422
                self.match(OMDParser.RPAREN)
                self.state = 423
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [37]:
                self.enterOuterAlt(localctx, 9)
                self.state = 425
                self.match(OMDParser.TRAPPE)
                self.state = 426
                self.match(OMDParser.LPAREN)
                self.state = 427
                self.doubleNumberTuple()
                self.state = 428
                self.match(OMDParser.RPAREN)
                self.state = 429
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 10)
                self.state = 431
                self.match(OMDParser.HARMONIC)
                self.state = 432
                self.match(OMDParser.LPAREN)
                self.state = 433
                self.doubleNumberTuple()
                self.state = 434
                self.match(OMDParser.RPAREN)
                self.state = 435
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversionblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INVERSION(self):
            return self.getToken(OMDParser.INVERSION, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def inversionstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.InversionstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.InversionstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_inversionblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversionblock" ):
                listener.enterInversionblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversionblock" ):
                listener.exitInversionblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversionblock" ):
                return visitor.visitInversionblock(self)
            else:
                return visitor.visitChildren(self)




    def inversionblock(self):

        localctx = OMDParser.InversionblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_inversionblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            self.match(OMDParser.INVERSION)
            self.state = 444
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 440
                self.match(OMDParser.LBRACKET)
                self.state = 441
                self.intConst()
                self.state = 442
                self.match(OMDParser.RBRACKET)


            self.state = 446
            self.match(OMDParser.LCURLY)
            self.state = 450
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4611690141663494144) != 0):
                self.state = 447
                self.inversionstatement()
                self.state = 452
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 453
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversionstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def CENTER(self):
            return self.getToken(OMDParser.CENTER, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def SATELLITES(self):
            return self.getToken(OMDParser.SATELLITES, 0)

        def inttuple(self):
            return self.getTypedRuleContext(OMDParser.InttupleContext,0)


        def AMBERIMPROPER(self):
            return self.getToken(OMDParser.AMBERIMPROPER, 0)

        def doubleNumberTuple(self):
            return self.getTypedRuleContext(OMDParser.DoubleNumberTupleContext,0)


        def IMPROPERCOSINE(self):
            return self.getToken(OMDParser.IMPROPERCOSINE, 0)

        def HARMONIC(self):
            return self.getToken(OMDParser.HARMONIC, 0)

        def CENTRALATOMHEIGHT(self):
            return self.getToken(OMDParser.CENTRALATOMHEIGHT, 0)

        def DREIDING(self):
            return self.getToken(OMDParser.DREIDING, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_inversionstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversionstatement" ):
                listener.enterInversionstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversionstatement" ):
                listener.exitInversionstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversionstatement" ):
                return visitor.visitInversionstatement(self)
            else:
                return visitor.visitChildren(self)




    def inversionstatement(self):

        localctx = OMDParser.InversionstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_inversionstatement)
        try:
            self.state = 498
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 455
                self.assignment()
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 2)
                self.state = 456
                self.match(OMDParser.CENTER)
                self.state = 457
                self.match(OMDParser.LPAREN)
                self.state = 458
                self.intConst()
                self.state = 459
                self.match(OMDParser.RPAREN)
                self.state = 460
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 3)
                self.state = 462
                self.match(OMDParser.SATELLITES)
                self.state = 463
                self.match(OMDParser.LPAREN)
                self.state = 464
                self.inttuple()
                self.state = 465
                self.match(OMDParser.RPAREN)
                self.state = 466
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 4)
                self.state = 468
                self.match(OMDParser.AMBERIMPROPER)
                self.state = 469
                self.match(OMDParser.LPAREN)
                self.state = 470
                self.doubleNumberTuple()
                self.state = 471
                self.match(OMDParser.RPAREN)
                self.state = 472
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [39]:
                self.enterOuterAlt(localctx, 5)
                self.state = 474
                self.match(OMDParser.IMPROPERCOSINE)
                self.state = 475
                self.match(OMDParser.LPAREN)
                self.state = 476
                self.doubleNumberTuple()
                self.state = 477
                self.match(OMDParser.RPAREN)
                self.state = 478
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 6)
                self.state = 480
                self.match(OMDParser.HARMONIC)
                self.state = 481
                self.match(OMDParser.LPAREN)
                self.state = 482
                self.doubleNumberTuple()
                self.state = 483
                self.match(OMDParser.RPAREN)
                self.state = 484
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [40]:
                self.enterOuterAlt(localctx, 7)
                self.state = 486
                self.match(OMDParser.CENTRALATOMHEIGHT)
                self.state = 487
                self.match(OMDParser.LPAREN)
                self.state = 488
                self.doubleNumberTuple()
                self.state = 489
                self.match(OMDParser.RPAREN)
                self.state = 490
                self.match(OMDParser.SEMICOLON)
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 8)
                self.state = 492
                self.match(OMDParser.DREIDING)
                self.state = 493
                self.match(OMDParser.LPAREN)
                self.state = 494
                self.doubleNumberTuple()
                self.state = 495
                self.match(OMDParser.RPAREN)
                self.state = 496
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RigidbodyblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGIDBODY(self):
            return self.getToken(OMDParser.RIGIDBODY, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def rigidbodystatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.RigidbodystatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.RigidbodystatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_rigidbodyblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRigidbodyblock" ):
                listener.enterRigidbodyblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRigidbodyblock" ):
                listener.exitRigidbodyblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRigidbodyblock" ):
                return visitor.visitRigidbodyblock(self)
            else:
                return visitor.visitChildren(self)




    def rigidbodyblock(self):

        localctx = OMDParser.RigidbodyblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_rigidbodyblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 500
            self.match(OMDParser.RIGIDBODY)
            self.state = 501
            self.match(OMDParser.LBRACKET)
            self.state = 502
            self.intConst()
            self.state = 503
            self.match(OMDParser.RBRACKET)
            self.state = 504
            self.match(OMDParser.LCURLY)
            self.state = 508
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==16 or _la==62:
                self.state = 505
                self.rigidbodystatement()
                self.state = 510
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 511
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RigidbodystatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def MEMBERS(self):
            return self.getToken(OMDParser.MEMBERS, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def inttuple(self):
            return self.getTypedRuleContext(OMDParser.InttupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_rigidbodystatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRigidbodystatement" ):
                listener.enterRigidbodystatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRigidbodystatement" ):
                listener.exitRigidbodystatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRigidbodystatement" ):
                return visitor.visitRigidbodystatement(self)
            else:
                return visitor.visitChildren(self)




    def rigidbodystatement(self):

        localctx = OMDParser.RigidbodystatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_rigidbodystatement)
        try:
            self.state = 520
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 513
                self.assignment()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 514
                self.match(OMDParser.MEMBERS)
                self.state = 515
                self.match(OMDParser.LPAREN)
                self.state = 516
                self.inttuple()
                self.state = 517
                self.match(OMDParser.RPAREN)
                self.state = 518
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CutoffgroupblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CUTOFFGROUP(self):
            return self.getToken(OMDParser.CUTOFFGROUP, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def cutoffgroupstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.CutoffgroupstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.CutoffgroupstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_cutoffgroupblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCutoffgroupblock" ):
                listener.enterCutoffgroupblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCutoffgroupblock" ):
                listener.exitCutoffgroupblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCutoffgroupblock" ):
                return visitor.visitCutoffgroupblock(self)
            else:
                return visitor.visitChildren(self)




    def cutoffgroupblock(self):

        localctx = OMDParser.CutoffgroupblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_cutoffgroupblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self.match(OMDParser.CUTOFFGROUP)
            self.state = 527
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 523
                self.match(OMDParser.LBRACKET)
                self.state = 524
                self.intConst()
                self.state = 525
                self.match(OMDParser.RBRACKET)


            self.state = 529
            self.match(OMDParser.LCURLY)
            self.state = 533
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==16 or _la==62:
                self.state = 530
                self.cutoffgroupstatement()
                self.state = 535
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 536
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CutoffgroupstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def MEMBERS(self):
            return self.getToken(OMDParser.MEMBERS, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def inttuple(self):
            return self.getTypedRuleContext(OMDParser.InttupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_cutoffgroupstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCutoffgroupstatement" ):
                listener.enterCutoffgroupstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCutoffgroupstatement" ):
                listener.exitCutoffgroupstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCutoffgroupstatement" ):
                return visitor.visitCutoffgroupstatement(self)
            else:
                return visitor.visitChildren(self)




    def cutoffgroupstatement(self):

        localctx = OMDParser.CutoffgroupstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_cutoffgroupstatement)
        try:
            self.state = 545
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 538
                self.assignment()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 539
                self.match(OMDParser.MEMBERS)
                self.state = 540
                self.match(OMDParser.LPAREN)
                self.state = 541
                self.inttuple()
                self.state = 542
                self.match(OMDParser.RPAREN)
                self.state = 543
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodesblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NODES(self):
            return self.getToken(OMDParser.NODES, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def nodesstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.NodesstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.NodesstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_nodesblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodesblock" ):
                listener.enterNodesblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodesblock" ):
                listener.exitNodesblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodesblock" ):
                return visitor.visitNodesblock(self)
            else:
                return visitor.visitChildren(self)




    def nodesblock(self):

        localctx = OMDParser.NodesblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_nodesblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            self.match(OMDParser.NODES)
            self.state = 552
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 548
                self.match(OMDParser.LBRACKET)
                self.state = 549
                self.intConst()
                self.state = 550
                self.match(OMDParser.RBRACKET)


            self.state = 554
            self.match(OMDParser.LCURLY)
            self.state = 558
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==16 or _la==62:
                self.state = 555
                self.nodesstatement()
                self.state = 560
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 561
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodesstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def MEMBERS(self):
            return self.getToken(OMDParser.MEMBERS, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def inttuple(self):
            return self.getTypedRuleContext(OMDParser.InttupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_nodesstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodesstatement" ):
                listener.enterNodesstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodesstatement" ):
                listener.exitNodesstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodesstatement" ):
                return visitor.visitNodesstatement(self)
            else:
                return visitor.visitChildren(self)




    def nodesstatement(self):

        localctx = OMDParser.NodesstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_nodesstatement)
        try:
            self.state = 570
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 563
                self.assignment()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 564
                self.match(OMDParser.MEMBERS)
                self.state = 565
                self.match(OMDParser.LPAREN)
                self.state = 566
                self.inttuple()
                self.state = 567
                self.match(OMDParser.RPAREN)
                self.state = 568
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FragmentblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FRAGMENT(self):
            return self.getToken(OMDParser.FRAGMENT, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def fragmentstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.FragmentstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.FragmentstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_fragmentblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFragmentblock" ):
                listener.enterFragmentblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFragmentblock" ):
                listener.exitFragmentblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFragmentblock" ):
                return visitor.visitFragmentblock(self)
            else:
                return visitor.visitChildren(self)




    def fragmentblock(self):

        localctx = OMDParser.FragmentblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_fragmentblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 572
            self.match(OMDParser.FRAGMENT)
            self.state = 573
            self.match(OMDParser.LCURLY)
            self.state = 577
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4611694814520418272) != 0):
                self.state = 574
                self.fragmentstatement()
                self.state = 579
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 580
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FragmentstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def atomblock(self):
            return self.getTypedRuleContext(OMDParser.AtomblockContext,0)


        def bondblock(self):
            return self.getTypedRuleContext(OMDParser.BondblockContext,0)


        def bendblock(self):
            return self.getTypedRuleContext(OMDParser.BendblockContext,0)


        def torsionblock(self):
            return self.getTypedRuleContext(OMDParser.TorsionblockContext,0)


        def inversionblock(self):
            return self.getTypedRuleContext(OMDParser.InversionblockContext,0)


        def rigidbodyblock(self):
            return self.getTypedRuleContext(OMDParser.RigidbodyblockContext,0)


        def cutoffgroupblock(self):
            return self.getTypedRuleContext(OMDParser.CutoffgroupblockContext,0)


        def constraintblock(self):
            return self.getTypedRuleContext(OMDParser.ConstraintblockContext,0)


        def nodesblock(self):
            return self.getTypedRuleContext(OMDParser.NodesblockContext,0)


        def getRuleIndex(self):
            return OMDParser.RULE_fragmentstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFragmentstatement" ):
                listener.enterFragmentstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFragmentstatement" ):
                listener.exitFragmentstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFragmentstatement" ):
                return visitor.visitFragmentstatement(self)
            else:
                return visitor.visitChildren(self)




    def fragmentstatement(self):

        localctx = OMDParser.FragmentstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_fragmentstatement)
        try:
            self.state = 592
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 582
                self.assignment()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 583
                self.atomblock()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 584
                self.bondblock()
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 4)
                self.state = 585
                self.bendblock()
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 5)
                self.state = 586
                self.torsionblock()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 6)
                self.state = 587
                self.inversionblock()
                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 7)
                self.state = 588
                self.rigidbodyblock()
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 8)
                self.state = 589
                self.cutoffgroupblock()
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 9)
                self.state = 590
                self.constraintblock()
                pass
            elif token in [43]:
                self.enterOuterAlt(localctx, 10)
                self.state = 591
                self.nodesblock()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintblockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRAINT(self):
            return self.getToken(OMDParser.CONSTRAINT, 0)

        def LCURLY(self):
            return self.getToken(OMDParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(OMDParser.RCURLY, 0)

        def LBRACKET(self):
            return self.getToken(OMDParser.LBRACKET, 0)

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def RBRACKET(self):
            return self.getToken(OMDParser.RBRACKET, 0)

        def constraintstatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.ConstraintstatementContext)
            else:
                return self.getTypedRuleContext(OMDParser.ConstraintstatementContext,i)


        def getRuleIndex(self):
            return OMDParser.RULE_constraintblock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintblock" ):
                listener.enterConstraintblock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintblock" ):
                listener.exitConstraintblock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintblock" ):
                return visitor.visitConstraintblock(self)
            else:
                return visitor.visitChildren(self)




    def constraintblock(self):

        localctx = OMDParser.ConstraintblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_constraintblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 594
            self.match(OMDParser.CONSTRAINT)
            self.state = 599
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 595
                self.match(OMDParser.LBRACKET)
                self.state = 596
                self.intConst()
                self.state = 597
                self.match(OMDParser.RBRACKET)


            self.state = 601
            self.match(OMDParser.LCURLY)
            self.state = 605
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==16 or _la==62:
                self.state = 602
                self.constraintstatement()
                self.state = 607
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 608
            self.match(OMDParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(OMDParser.AssignmentContext,0)


        def MEMBERS(self):
            return self.getToken(OMDParser.MEMBERS, 0)

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def inttuple(self):
            return self.getTypedRuleContext(OMDParser.InttupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_constraintstatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintstatement" ):
                listener.enterConstraintstatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintstatement" ):
                listener.exitConstraintstatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintstatement" ):
                return visitor.visitConstraintstatement(self)
            else:
                return visitor.visitChildren(self)




    def constraintstatement(self):

        localctx = OMDParser.ConstraintstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_constraintstatement)
        try:
            self.state = 617
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 610
                self.assignment()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 611
                self.match(OMDParser.MEMBERS)
                self.state = 612
                self.match(OMDParser.LPAREN)
                self.state = 613
                self.inttuple()
                self.state = 614
                self.match(OMDParser.RPAREN)
                self.state = 615
                self.match(OMDParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequencestringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEQUENCE(self):
            return self.getToken(OMDParser.SEQUENCE, 0)

        def ASSIGNEQUAL(self):
            return self.getToken(OMDParser.ASSIGNEQUAL, 0)

        def constant(self):
            return self.getTypedRuleContext(OMDParser.ConstantContext,0)


        def SEMICOLON(self):
            return self.getToken(OMDParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_sequencestring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequencestring" ):
                listener.enterSequencestring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequencestring" ):
                listener.exitSequencestring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSequencestring" ):
                return visitor.visitSequencestring(self)
            else:
                return visitor.visitChildren(self)




    def sequencestring(self):

        localctx = OMDParser.SequencestringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_sequencestring)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 619
            self.match(OMDParser.SEQUENCE)
            self.state = 620
            self.match(OMDParser.ASSIGNEQUAL)
            self.state = 621
            self.constant()
            self.state = 622
            self.match(OMDParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoubleNumberTupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def doubleNumber(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.DoubleNumberContext)
            else:
                return self.getTypedRuleContext(OMDParser.DoubleNumberContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(OMDParser.COMMA)
            else:
                return self.getToken(OMDParser.COMMA, i)

        def getRuleIndex(self):
            return OMDParser.RULE_doubleNumberTuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleNumberTuple" ):
                listener.enterDoubleNumberTuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleNumberTuple" ):
                listener.exitDoubleNumberTuple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoubleNumberTuple" ):
                return visitor.visitDoubleNumberTuple(self)
            else:
                return visitor.visitChildren(self)




    def doubleNumberTuple(self):

        localctx = OMDParser.DoubleNumberTupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_doubleNumberTuple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            self.doubleNumber()
            self.state = 629
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 625
                self.match(OMDParser.COMMA)
                self.state = 626
                self.doubleNumber()
                self.state = 631
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InttupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intConst(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(OMDParser.IntConstContext)
            else:
                return self.getTypedRuleContext(OMDParser.IntConstContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(OMDParser.COMMA)
            else:
                return self.getToken(OMDParser.COMMA, i)

        def getRuleIndex(self):
            return OMDParser.RULE_inttuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInttuple" ):
                listener.enterInttuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInttuple" ):
                listener.exitInttuple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInttuple" ):
                return visitor.visitInttuple(self)
            else:
                return visitor.visitChildren(self)




    def inttuple(self):

        localctx = OMDParser.InttupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_inttuple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 632
            self.intConst()
            self.state = 637
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 633
                self.match(OMDParser.COMMA)
                self.state = 634
                self.intConst()
                self.state = 639
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUM_INT(self):
            return self.getToken(OMDParser.NUM_INT, 0)

        def NUM_LONG(self):
            return self.getToken(OMDParser.NUM_LONG, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_intConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntConst" ):
                listener.enterIntConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntConst" ):
                listener.exitIntConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntConst" ):
                return visitor.visitIntConst(self)
            else:
                return visitor.visitChildren(self)




    def intConst(self):

        localctx = OMDParser.IntConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_intConst)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 640
            _la = self._input.LA(1)
            if not(_la==56 or _la==57):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoubleNumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intConst(self):
            return self.getTypedRuleContext(OMDParser.IntConstContext,0)


        def floatConst(self):
            return self.getTypedRuleContext(OMDParser.FloatConstContext,0)


        def getRuleIndex(self):
            return OMDParser.RULE_doubleNumber

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleNumber" ):
                listener.enterDoubleNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleNumber" ):
                listener.exitDoubleNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoubleNumber" ):
                return visitor.visitDoubleNumber(self)
            else:
                return visitor.visitChildren(self)




    def doubleNumber(self):

        localctx = OMDParser.DoubleNumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_doubleNumber)
        try:
            self.state = 644
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [56, 57]:
                self.enterOuterAlt(localctx, 1)
                self.state = 642
                self.intConst()
                pass
            elif token in [58, 59]:
                self.enterOuterAlt(localctx, 2)
                self.state = 643
                self.floatConst()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FloatConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUM_FLOAT(self):
            return self.getToken(OMDParser.NUM_FLOAT, 0)

        def NUM_DOUBLE(self):
            return self.getToken(OMDParser.NUM_DOUBLE, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_floatConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloatConst" ):
                listener.enterFloatConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloatConst" ):
                listener.exitFloatConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloatConst" ):
                return visitor.visitFloatConst(self)
            else:
                return visitor.visitChildren(self)




    def floatConst(self):

        localctx = OMDParser.FloatConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_floatConst)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 646
            _la = self._input.LA(1)
            if not(_la==58 or _la==59):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VectorConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(OMDParser.LPAREN, 0)

        def doubleNumberTuple(self):
            return self.getTypedRuleContext(OMDParser.DoubleNumberTupleContext,0)


        def RPAREN(self):
            return self.getToken(OMDParser.RPAREN, 0)

        def getRuleIndex(self):
            return OMDParser.RULE_vectorConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVectorConst" ):
                listener.enterVectorConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVectorConst" ):
                listener.exitVectorConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVectorConst" ):
                return visitor.visitVectorConst(self)
            else:
                return visitor.visitChildren(self)




    def vectorConst(self):

        localctx = OMDParser.VectorConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_vectorConst)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 648
            self.match(OMDParser.LPAREN)
            self.state = 649
            self.doubleNumberTuple()
            self.state = 650
            self.match(OMDParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





